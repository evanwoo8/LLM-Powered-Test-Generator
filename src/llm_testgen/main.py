import argparse
import ast
import os
from pathlib import Path
from src.llm_testgen.ast_methods import extract_functions
from src.llm_testgen.llm import format_prompt, query_llm
from src.llm_testgen.guardrails import with_guardrails

def parse_python_file(file_path):
    with open(file_path, 'r') as file:
        source_code = file.read()
    return (source_code, ast.parse(source_code))

def save_to_file(test_code: str, source_file: str, func_name: str):
    """
    Saves generated tests into <source_file>_tests.py.
    - Keeps a single 'from source_file import func1, func2, ...' line.
    - Appends new function names if missing.
    - Appends test code at the bottom.
    """
    filename = f"{source_file}_tests.py"
    header = f"# Auto-generated by LLM TestGen\nimport pytest\nfrom {source_file} import {func_name}\n\n"

    if not os.path.exists(filename):
        # Create file fresh with header
        with open(filename, "w", encoding="utf-8") as f:
            f.write(header)
            f.write(test_code.rstrip() + "\n")
    else:
        # Read existing file
        lines = Path(filename).read_text(encoding="utf-8").splitlines()

        # Find the import line
        import_idx = None
        for i, line in enumerate(lines):
            if line.startswith(f"from {source_file} import"):
                import_idx = i
                break

        if import_idx is not None:
            # Append func_name if not already imported
            if func_name not in lines[import_idx]:
                lines[import_idx] = lines[import_idx].rstrip() + f", {func_name}"
        else:
            # If import line somehow missing, add a new one
            lines.insert(2, f"from {source_file} import {func_name}")

        # Write back header + existing code
        with open(filename, "w", encoding="utf-8") as f:
            f.write("\n".join(lines) + "\n")
            f.write("\n" + test_code.rstrip() + "\n")

def main():
    parser = argparse.ArgumentParser(description="CLI for generating unit tests with LLM")
    parser.add_argument('file', help='Path to Python file you want to analyze')
    parser.add_argument("--model", default="codellama:7b-instruct", help="Ollama model to use")
    args = parser.parse_args()
    user_file = args.file
    source_file_name = os.path.splitext(os.path.basename(user_file))[0]

    try:
        source_and_parsed = parse_python_file(user_file)
        print(f"Trying to parse file: {user_file}")
        source_code = source_and_parsed[0]
        ast_parsed = source_and_parsed[1]
        print('hi')
        functions_list = extract_functions(source_code, ast_parsed)
        for function_dict in functions_list:
            print(function_dict['name'])
            prompt = format_prompt(function_dict)
            test_code = with_guardrails(prompt, function_dict["name"], model=args.model)
            save_to_file(test_code, source_file_name, function_dict['name'])


    except Exception as e:
        print(f"Error parsing your file: {e}")

# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    main()

